---
title: 持续事件
lang: zh-CN
---

# 持续事件

目前为止，有“持续 - 全局”和“持续 - 每名玩家”两个持续事件。它们有一些难以把握。官方说：“当首次检查就满足条件时，则会执行行动。当未满足条件列表，但之后又满足时，则会尝试再次执行行动”。

我们举一些例子，来看看持续事件到底怎么回事。

## 只运行一次

使用持续事件但不附加任何条件，它在一次游戏中只会运行一次。你可以借此实现初始化。

## 结合“循环”多次运行

例如，我们想追踪玩家位置，如果玩家的Z坐标大于100，我们就每秒给玩家恢复100点生命值：

事件
* 持续 - 每名玩家

条件
* Z方向分量(位置(事件玩家)) > 100

动作
* 等待(1, 无视条件)
* 治疗(事件玩家, 无, 100)
* 如条件为“真”则循环

如果没有`如条件为“真”则循环`，那么便达不到我们的目的，因为条件并没有从满足变为不满足再变为满足，规则就只会运行一次。

## 根据条件多次运行

例如，我们想追踪玩家位置，如果玩家的Z坐标大于100，我们就在3秒后将玩家移动到某个位置：

事件
* 持续 - 每名玩家

条件
* Z方向分量(位置(事件玩家)) > 100

动作
* 等待(3, 无视条件)
* 传送(事件玩家, 矢量(0, 0, 0))

这个规则能达到我们的目的，但它是有问题的：如果一个玩家在Z=100的地方进进出出（即一会儿小于100，一会儿又大于100），那么玩家就会被多次传送。原因是，“当未满足条件列表，但之后又满足时，则会尝试再次执行行动”。这种情况叫“抖动”。

解决方法有两个，最简单的便是把等待改成`等待(3, 当为“假”时中止)`。这是最简单的，但不一定适合所有情况。我们在这里介绍一种比较通用的方法：做一个“锁”。假设我们需要：玩家首次进入Z>100的范围，3s后传送。那么，我们可以这样写动作：

* 根据条件跳过(玩家变量(事件玩家, C), 1)
* 中止
* 设置玩家变量(事件玩家, C, 真)
* 等待(3, 无视条件)
* 传送(事件玩家, 矢量(0, 0, 0))
* 设置玩家变量(事件玩家, C, 假)

这里的玩家变量C变成为了一个“锁”。如果我们没有拿到锁，那么这条规则直接中止。否则才会向下执行。在传送完后，再把“锁”释放掉，让别人能“再来一次”。
